{
  "metadata": {
    "sertop_args": []
  },
  "chunks": [
    "Require Coq.Vectors.Vector.\nRequire Import Coq.Strings.String Coq.Arith.PeanoNat.",
    "Import EqNotations Vector.VectorNotations.\nCompute (Vector.hd (rew (Nat.add_1_r 3) in ([1; 2; 3] ++ [4]))).",
    "Definition transparent : nat := 1 + 1.\nCompute transparent. (* .unfold *)\n\nLemma opaque : 1 + 1 = 2. Proof. auto. Qed.\nCompute opaque. (* .unfold *)",
    "Definition snoc {A n} (a: A) (v: Vector.t A n)\n  : Vector.t A (S n) :=\n  (* [Nat.add_1_r] has type [forall n : nat, n + 1 = S n] *)\n  rew (Nat.add_1_r n) in (v ++ [a]).",
    "Definition snoc_proofmode {A n} (a: A) (v: Vector.t A n)\n  : Vector.t A (S n).\nProof.\n  rewrite <- Nat.add_1_r.\n  exact (v ++ [a]).\nDefined.",
    "Compute (Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3])). (* .unfold *)",
    "Lemma map_snoc_1234 :\n  Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3]) = [2; 4; 6; 8].\nProof.",
    "  Fail reflexivity. (* .unfold .no-goals *)",
    "  cbv -[Vector.map Nat.mul eq_rect].\n  unfold eq_rect.",
    "Abort.",
    "Lemma map_snoc_1234 :\n  Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3]) = [2; 4; 6; 8].\nProof.\n  cbv -[Vector.map Nat.mul].\n  Fail destruct (Nat.add_1_r 3). (* .unfold .no-goals *)\nAbort.",
    "Lemma map_app {A B} (f: A -> B):\n  forall {n1} (v1: Vector.t A n1)\n         {n2} (v2: Vector.t A n2),\n    Vector.map f (v1 ++ v2) =\n    Vector.map f v1 ++ Vector.map f v2.\nProof. induction v1; cbn; congruence. Qed.",
    "Lemma snoc_map {A B n} :\n  forall (v: Vector.t A n) (f: A -> B) a,\n    Vector.map f (snoc a v) =\n    snoc (f a) (Vector.map f v). (* .fold *)\nProof. (* .fold *)\n  intros; unfold snoc.\n  destruct (Nat.add_1_r n).",
    "  cbn.\n  rewrite map_app. (* .unfold *)\n  reflexivity.\nQed.",
    "Lemma map_snoc_1234 :\n  Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3]) = [2; 4; 6; 8].\nProof.\n  rewrite snoc_map.\n  cbv. (* .unfold *)",
    "  Fail destruct (Nat.add_1_r 3).",
    "  rewrite (Eqdep_dec.UIP_refl_nat _ (Nat.add_1_r 3)).\n  reflexivity.\nQed.",
    "Lemma add_1_r_transparent_proofmode (n: nat) : n + 1 = S n.\nProof.\n  induction n.\n  - reflexivity.\n  - cbn.\n    rewrite IHn.\n    reflexivity.\nDefined. (* [Defined] makes the proof transparent *)",
    "Fixpoint add_1_r_transparent (n: nat)\n  : n + 1 = S n :=\n  match n with\n  | 0 => eq_refl\n  | S n =>\n    match add_1_r_transparent n in (_ = y)\n      return (S n + 1 = S y) with\n    | eq_refl => eq_refl\n    end\n  end.",
    "Definition snoc_computational {A n} (a: A) (v: Vector.t A n)\n  : Vector.t A (S n) :=\n  rew (add_1_r_transparent n) in (v ++ [a]).",
    "Compute (Vector.map (fun x => 2 * x)\n                    (snoc_computational 4 [1; 2; 3])).",
    "Definition computational_eq {m n} (opaque_eq: m = n) : m = n :=\n  match Nat.eq_dec m n with\n  | left transparent_eq => transparent_eq\n  | _ => opaque_eq (* dead code; could use [False_rect] *)\n  end.",
    "Definition snoc' {A n} (a: A) (v: Vector.t A n) :=\n  rew (computational_eq (Nat.add_1_r n)) in (v ++ [a]).",
    "Compute (Vector.map (fun x => 2 * x) (snoc' 4 [1; 2; 3])).",
    "Compute (@Fin.of_nat_lt 3 4 (PeanoNat.Nat.lt_succ_diag_r 3)).",
    "Definition computational_eq_cbv {m n: nat}\n    (thunked_eq: unit -> m = n) : m = n :=\n  match Nat.eq_dec m n with\n  | left transparent_eq => transparent_eq\n  | _ => thunked_eq tt\n  end.",
    "Require Import Extraction. (* .none *)\nExtraction computational_eq."
  ],
  "annotated": [
    [
      {
        "_type": "sentence",
        "contents": "Require Coq.Vectors.Vector.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Require Import Coq.Strings.String Coq.Arith.PeanoNat.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Import EqNotations Vector.VectorNotations.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Compute (Vector.hd (rew (Nat.add_1_r 3) in ([1; 2; 3] ++ [4]))).",
        "responses": [
          "     = match\n         match\n           Nat.add_1_r 3 in (_ = H)\n           return (Vector.t nat H)\n         with\n         | eq_refl => [1; 2; 3; 4]\n         end as c in (Vector.t _ H)\n         return\n           (match\n              H as c0 return (Vector.t nat c0 -> Type)\n            with\n            | 0 =>\n                fun _ : Vector.t nat 0 =>\n                False -> forall x1 : Prop, x1 -> x1\n            | S x => fun _ : Vector.t nat (S x) => nat\n            end c)\n       with\n       | [] =>\n           fun x : False =>\n           match\n             x return (forall x0 : Prop, x0 -> x0)\n           with\n           end\n       | h :: _ => h\n       end\n     : (fun (n : nat) (_ : Vector.t nat (S n)) => nat)\n         3\n         (rew [Vector.t nat] Nat.add_1_r 3 in\n          ([1; 2; 3] ++ [4]))"
        ],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition transparent : nat := 1 + 1.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Compute transparent.",
        "responses": [
          "     = 2\n     : nat"
        ],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " (* .unfold *)\n\n"
      },
      {
        "_type": "sentence",
        "contents": "Lemma opaque : 1 + 1 = 2.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "1 + 1 = 2",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "1 + 1 = 2",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "auto.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "Qed.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Compute opaque.",
        "responses": [
          "     = opaque\n     : 1 + 1 = 2"
        ],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " (* .unfold *)"
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition snoc {A n} (a: A) (v: Vector.t A n)\n  : Vector.t A (S n) :=\n  (* [Nat.add_1_r] has type [forall n : nat, n + 1 = S n] *)\n  rew (Nat.add_1_r n) in (v ++ [a]).",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition snoc_proofmode {A n} (a: A) (v: Vector.t A n)\n  : Vector.t A (S n).",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.t A (S n)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.t A (S n)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "rewrite <- Nat.add_1_r.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.t A (n + 1)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "exact (v ++ [a]).",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Defined.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Compute (Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3])).",
        "responses": [
          "     = (fix\n        Ffix (x : nat) (x0 : Vector.t nat x) {struct\n             x0} : Vector.t nat x :=\n          match\n            x0 in (Vector.t _ H)\n            return (Vector.t nat H)\n          with\n          | [] => []\n          | Vector.cons _ h n x1 =>\n              (fix Ffix0 (x2 x3 : nat) {struct x2} :\n                 nat :=\n                 match x2 with\n                 | 0 => x3\n                 | S x4 => S (Ffix0 x4 x3)\n                 end) h\n                ((fix\n                  Ffix0 (x2 x3 : nat) {struct x2} :\n                    nat :=\n                    match x2 with\n                    | 0 => x3\n                    | S x4 => S (Ffix0 x4 x3)\n                    end) h 0) :: Ffix n x1\n          end) 4\n         match\n           Nat.add_1_r 3 in (_ = H)\n           return (Vector.t nat H)\n         with\n         | eq_refl => [1; 2; 3; 4]\n         end\n     : Vector.t nat 4"
        ],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " (* .unfold *)"
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Lemma map_snoc_1234 :\n  Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3]) = [2; 4; 6; 8].",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      }
    ],
    [
      {
        "_type": "text",
        "contents": "  "
      },
      {
        "_type": "sentence",
        "contents": "Fail reflexivity.",
        "responses": [
          "The command has indeed failed with message:\nUnable to unify \"[2; 4; 6; 8]\" with\n \"Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3])\"."
        ],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": " (* .unfold .no-goals *)"
      }
    ],
    [
      {
        "_type": "text",
        "contents": "  "
      },
      {
        "_type": "sentence",
        "contents": "cbv -[Vector.map Nat.mul eq_rect].",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x)\n  (rew [Vector.t nat] Nat.add_1_r 3 in [1; 2; 3; 4]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "unfold eq_rect.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x)\n  match\n    Nat.add_1_r 3 in (_ = y) return (Vector.t nat y)\n  with\n  | eq_refl => [1; 2; 3; 4]\n  end = [2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Abort.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Lemma map_snoc_1234 :\n  Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3]) = [2; 4; 6; 8].",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "cbv -[Vector.map Nat.mul].",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x)\n  match\n    Nat.add_1_r 3 in (_ = y) return (Vector.t nat y)\n  with\n  | eq_refl => [1; 2; 3; 4]\n  end = [2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "Fail destruct (Nat.add_1_r 3).",
        "responses": [
          "The command has indeed failed with message:\nAbstracting over the terms \"n\" and \"e\" leads to a term\nfun (n0 : nat) (e0 : 3 + 1 = n0) =>\nVector.map (fun x : nat => 2 * x)\n  match e0 in (_ = y) return (Vector.t nat y) with\n  | eq_refl => [1; 2; 3; n0]\n  end = [2; n0; S (S n0); S (S (S (S n0)))]\nwhich is ill-typed.\nReason is: Incorrect elimination of \"e0\"\n           in the inductive type \"@eq\":\nill-formed elimination predicate."
        ],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x)\n  match\n    Nat.add_1_r 3 in (_ = y) return (Vector.t nat y)\n  with\n  | eq_refl => [1; 2; 3; 4]\n  end = [2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": " (* .unfold .no-goals *)\n"
      },
      {
        "_type": "sentence",
        "contents": "Abort.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Lemma map_app {A B} (f: A -> B):\n  forall {n1} (v1: Vector.t A n1)\n         {n2} (v2: Vector.t A n2),\n    Vector.map f (v1 ++ v2) =\n    Vector.map f v1 ++ Vector.map f v2.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "forall (n1 : nat) (v1 : Vector.t A n1) (n2 : nat)\n  (v2 : Vector.t A n2),\nVector.map f (v1 ++ v2) =\nVector.map f v1 ++ Vector.map f v2",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "f"
                ],
                "body": null,
                "type": "A -> B"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "forall (n1 : nat) (v1 : Vector.t A n1) (n2 : nat)\n  (v2 : Vector.t A n2),\nVector.map f (v1 ++ v2) =\nVector.map f v1 ++ Vector.map f v2",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "f"
                ],
                "body": null,
                "type": "A -> B"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "induction v1; cbn; congruence.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "Qed.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Lemma snoc_map {A B n} :\n  forall (v: Vector.t A n) (f: A -> B) a,\n    Vector.map f (snoc a v) =\n    snoc (f a) (Vector.map f v).",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "forall (v : Vector.t A n) (f : A -> B) (a : A),\nVector.map f (snoc a v) = snoc (f a) (Vector.map f v)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": " (* .fold *)\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "forall (v : Vector.t A n) (f : A -> B) (a : A),\nVector.map f (snoc a v) = snoc (f a) (Vector.map f v)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": " (* .fold *)\n  "
      },
      {
        "_type": "sentence",
        "contents": "intros; unfold snoc.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map f\n  (rew [Vector.t A] Nat.add_1_r n in (v ++ [a])) =\nrew [Vector.t B] Nat.add_1_r n in\n(Vector.map f v ++ [f a])",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "f"
                ],
                "body": null,
                "type": "A -> B"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "destruct (Nat.add_1_r n).",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map f (rew [Vector.t A] eq_refl in (v ++ [a])) =\nrew [Vector.t B] eq_refl in (Vector.map f v ++ [f a])",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "f"
                ],
                "body": null,
                "type": "A -> B"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              }
            ]
          }
        ]
      }
    ],
    [
      {
        "_type": "text",
        "contents": "  "
      },
      {
        "_type": "sentence",
        "contents": "cbn.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map f (v ++ [a]) = Vector.map f v ++ [f a]",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "f"
                ],
                "body": null,
                "type": "A -> B"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "rewrite map_app.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map f v ++ Vector.map f [a] =\nVector.map f v ++ [f a]",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "A"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "B"
                ],
                "body": null,
                "type": "Type"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "v"
                ],
                "body": null,
                "type": "Vector.t A n"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "f"
                ],
                "body": null,
                "type": "A -> B"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "a"
                ],
                "body": null,
                "type": "A"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": " (* .unfold *)\n  "
      },
      {
        "_type": "sentence",
        "contents": "reflexivity.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Qed.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Lemma map_snoc_1234 :\n  Vector.map (fun x => 2 * x) (snoc 4 [1; 2; 3]) = [2; 4; 6; 8].",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "Vector.map (fun x : nat => 2 * x) (snoc 4 [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "rewrite snoc_map.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "snoc (2 * 4)\n  (Vector.map (fun x : nat => 2 * x) [1; 2; 3]) =\n[2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "cbv.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "match\n  Nat.add_1_r 3 in (_ = y) return (Vector.t nat y)\nwith\n| eq_refl => [2; 4; 6; 8]\nend = [2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": " (* .unfold *)"
      }
    ],
    [
      {
        "_type": "text",
        "contents": "  "
      },
      {
        "_type": "sentence",
        "contents": "Fail destruct (Nat.add_1_r 3).",
        "responses": [
          "The command has indeed failed with message:\nAbstracting over the terms \"n\" and \"e\" leads to a term\nfun (n0 : nat) (e0 : 3 + 1 = n0) =>\nmatch e0 in (_ = y) return (Vector.t nat y) with\n| eq_refl => [2; n0; S (S n0); S (S (S (S n0)))]\nend = [2; n0; S (S n0); S (S (S (S n0)))]\nwhich is ill-typed.\nReason is: Incorrect elimination of \"e0\"\n           in the inductive type \"@eq\":\nill-formed elimination predicate."
        ],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "match\n  Nat.add_1_r 3 in (_ = y) return (Vector.t nat y)\nwith\n| eq_refl => [2; 4; 6; 8]\nend = [2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      }
    ],
    [
      {
        "_type": "text",
        "contents": "  "
      },
      {
        "_type": "sentence",
        "contents": "rewrite (Eqdep_dec.UIP_refl_nat _ (Nat.add_1_r 3)).",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "[2; 4; 6; 8] = [2; 4; 6; 8]",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "reflexivity.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Qed.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Lemma add_1_r_transparent_proofmode (n: nat) : n + 1 = S n.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "n + 1 = S n",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Proof.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "n + 1 = S n",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "induction n.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "0 + 1 = 1",
            "hypotheses": []
          },
          {
            "_type": "goal",
            "name": null,
            "conclusion": "S n + 1 = S (S n)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "IHn"
                ],
                "body": null,
                "type": "n + 1 = S n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "-",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "0 + 1 = 1",
            "hypotheses": []
          }
        ]
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "reflexivity.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n  "
      },
      {
        "_type": "sentence",
        "contents": "-",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "S n + 1 = S (S n)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "IHn"
                ],
                "body": null,
                "type": "n + 1 = S n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": " "
      },
      {
        "_type": "sentence",
        "contents": "cbn.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "S (n + 1) = S (S n)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "IHn"
                ],
                "body": null,
                "type": "n + 1 = S n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n    "
      },
      {
        "_type": "sentence",
        "contents": "rewrite IHn.",
        "responses": [],
        "goals": [
          {
            "_type": "goal",
            "name": null,
            "conclusion": "S (S n) = S (S n)",
            "hypotheses": [
              {
                "_type": "hypothesis",
                "names": [
                  "n"
                ],
                "body": null,
                "type": "nat"
              },
              {
                "_type": "hypothesis",
                "names": [
                  "IHn"
                ],
                "body": null,
                "type": "n + 1 = S n"
              }
            ]
          }
        ]
      },
      {
        "_type": "text",
        "contents": "\n    "
      },
      {
        "_type": "sentence",
        "contents": "reflexivity.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": "\n"
      },
      {
        "_type": "sentence",
        "contents": "Defined.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " (* [Defined] makes the proof transparent *)"
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Fixpoint add_1_r_transparent (n: nat)\n  : n + 1 = S n :=\n  match n with\n  | 0 => eq_refl\n  | S n =>\n    match add_1_r_transparent n in (_ = y)\n      return (S n + 1 = S y) with\n    | eq_refl => eq_refl\n    end\n  end.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition snoc_computational {A n} (a: A) (v: Vector.t A n)\n  : Vector.t A (S n) :=\n  rew (add_1_r_transparent n) in (v ++ [a]).",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Compute (Vector.map (fun x => 2 * x)\n                    (snoc_computational 4 [1; 2; 3])).",
        "responses": [
          "     = [2; 4; 6; 8]\n     : Vector.t nat 4"
        ],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition computational_eq {m n} (opaque_eq: m = n) : m = n :=\n  match Nat.eq_dec m n with\n  | left transparent_eq => transparent_eq\n  | _ => opaque_eq (* dead code; could use [False_rect] *)\n  end.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition snoc' {A n} (a: A) (v: Vector.t A n) :=\n  rew (computational_eq (Nat.add_1_r n)) in (v ++ [a]).",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Compute (Vector.map (fun x => 2 * x) (snoc' 4 [1; 2; 3])).",
        "responses": [
          "     = [2; 4; 6; 8]\n     : Vector.t nat 4"
        ],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Compute (@Fin.of_nat_lt 3 4 (PeanoNat.Nat.lt_succ_diag_r 3)).",
        "responses": [
          "     = Fin.FS (Fin.FS (Fin.FS Fin.F1))\n     : Fin.t 4"
        ],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Definition computational_eq_cbv {m n: nat}\n    (thunked_eq: unit -> m = n) : m = n :=\n  match Nat.eq_dec m n with\n  | left transparent_eq => transparent_eq\n  | _ => thunked_eq tt\n  end.",
        "responses": [],
        "goals": []
      }
    ],
    [
      {
        "_type": "sentence",
        "contents": "Require Import Extraction.",
        "responses": [],
        "goals": []
      },
      {
        "_type": "text",
        "contents": " (* .none *)\n"
      },
      {
        "_type": "sentence",
        "contents": "Extraction computational_eq.",
        "responses": [
          "(** val computational_eq : __ **)\n\nlet computational_eq =\n  __"
        ],
        "goals": []
      }
    ]
  ]
}